## 📍 인증과 인가

### ✔️ 인증 (**Authentication)**

**→ “Who You Are”**

사용자의 신원을 확인하는 것.

인증은 사용자가 사용자와 시스템간에 공유되는 ‘합의된 정보’를 시스템에게 전달하여 자신의 신원을 증명하는 과정이다.

여기서 합의된 정보는, 로그인 프로세스라고 한다면 아이디와 비밀번호가 바로 합의된 정보가 될 것이다.

→ 이를 통해 사용자의 신원을 확인할 수 있는 것!

### ✔️ 인가 (**Authorization)**

**→ “What You Can Do”**

사용자에게 권한을 부여하거나 거부하는 것.

자세히는 신원이 확인된 사용자에게 특정 리소스나 기능에 액세스할 수 있는 권한을 부여하는 것이다.

<br/>

## 📍 쿠키와 세션

### ✔️ 쿠키 (Cookie)

쿠키는 HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.

클라이언트가 서버로 로그인 요청을 하게 되면, 서버는 쿠키를 생성하여 응답을 하고 클라이언트가 그 쿠키를 받아 로컬에 저장한다.

그 후 서버에 요청할 때 쿠키를 포함하여 요청하면 서버는 쿠키를 통해 상태를 식별하고 그에 맞는 응답을 전달하는 방식이다.

### ✔️ 세션 (Session)

클라이언트가 웹 서버에 접속해있는 상태를 세션이라 한다.

세션은 클라이언트가 웹 서버에 접속한 시점부터 웹 브라우저가 종료될 때까지 클라이언트의 상태를 유지한다.

세션은 각 클라이언트의 고유세션 ID를 부여하는데, 이것으로 클라이언트를 구분하여 각 클라이언트의 요구에 맞는 응답을 반환한다.

→ 서버에 중요 정보를 저장해두고, 클라이언트는 쿠키에 세션 ID를 넣어서 통신!

### ✔️ 쿠키 vs 세션

|           | 쿠키              | 세션                    |
| --------- | ----------------- | ----------------------- |
| 저장 위치 | 클라이언트        | 서버                    |
| 보안      | 취약              | 안전                    |
| 만료시점  | 쿠키 저장 시 설정 | 브라우저 종료 시 삭제됨 |
| 속도      | 빠름              | 느림                    |
| Stateless | O                 | X                       |

<br/>

## 📍 JWT

쿠키와 세션의 각각의 장단점이 존재하지만 어느 하나가 다른 하나의 단점을 완전히 보완하면서 장점은 유지하는 것은 아니다.

그래서 등장한 것이 바로 JWT이다.

### ✔️ 토큰이 필요한 이유?

Stateful 서버는 클라이언트에게서 요청을 받을 때 마다, 클라이언트의 상태를 계속해서 유지하고, 이 정보를 서비스 제공에 이용한다.

→ 세션이 바로 이런 구조로 작동하는 것!

그러나 HTTP는 **Stateless** 특성을 가지고 있는데, stateless는 상태를 유지하지 않는다.

상태정보를 저장하지 않으면, 서버는 클라이언트측에서 들어오는 요청만으로만 작업을 처리하기 때문에 클라이언트의 상태값(ex. 로그인 정보)을 식별할 수 없게 되어 매번 로그인 과정을 거쳐야하는 번거로움이 발생한다.

→ 이를 방지하여 로그인 상태를 유지하면서도 stateless 특성을 잃지 않도록 사용되는 것이 토큰!

### ✔️ JWT 개념

JWT(Json Web Token)은 Json 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰으로, 인터넷 표준 인증 방식이다.

공식적으로 **인증(Authentication) & 인가(Authorization)** 방식으로 사용된다.

클라이언트가 로그인 요청을 하면 서버가 사용자 정보가 암호화 되어있는 토큰을 만들어 보내게 되고, 이를 이용하여 이후 요청 시 인증된 사용자인지 판단한다.

### ✔️ JWT의 주요 장점

- 암호화 되어 있어 보안에 강하다.
- 별도의 저장소가 필요하지 않다.
- Stateful한 세션과 다르게 서버가 Stateless한 특성이 유지된다.
- 확장성이 우수하다.

### ✔️ JWT 기반 로그인 과정

![1_TTJNiU4kk3ug856FwdsOKw](https://github.com/JIMIN1020/dev-study-note/assets/121474189/fb87f038-c07b-4d1e-9560-8cdeb4860fe6)

1. 클라언트가 서버로 회원가입/로그인 요청을 보냄.
2. 서버가 사용자 정보를 담은 토큰을 생성하고 저장함.
3. 회원가입/로그인 요청에 대한 응답으로 토큰을 보냄.
4. 이 후 클라이언트는 서버에 요청 시 토큰과 함께 요청.
5. 서버는 토큰으로 사용자 정보를 식별하고 응답함.

### ✔️ JWT 구조

JWT는 크게 Header, Payload, Signature 3가지 파트로 구성되어 있다.

JSON으로 작성된 내용을 `base64` 로 인코딩 된 것이 바로 JWT!

![R800x0](https://github.com/JIMIN1020/dev-study-note/assets/121474189/5526d0ce-b0f8-43b3-be38-8d9ad84a5819)

- **Header**
  - `typ` : 토큰의 타입
  - `alg` : 해싱 알고리즘
- **Payload**
  토큰에 담을 정보가 들어있는데, 여기서 정보의 한 조각을 클레임(claim)이라 부르고 ‘key: value’ 쌍으로 이루어져 있다.
- **Signature**
  헤더의 인코딩값과, 정보의 인코딩값을 합친후 주어진 비밀키로 해쉬 알고리즘을 적용하여 생성한 서명이다.

JWT 토큰을 인코딩, 디코딩 하는 과정은 다음 공식 웹사이트에서 직접 해볼 수 있다.
[JWT.IO](https://jwt.io/)

<br/>

## 📍 JWT 실습

### ✔️ 설치

```bash
npm i jsonwebtoken
```

### ✔️ sign

`jsonwebtoken` 모듈의 `sign` 메소드로 토큰을 생성할 수 있다.

첫번째 인자로는 payload에 담을 문자열이나 객체, 버퍼 등을 전달하고,

두번째 인자로는 복호화할 때 사용할 개인키, 세번째 인자로는 옵션을 전달한다.

```jsx
const jwt = require("jsonwebtoken");

// token 생성 = 서명
const token = jwt.sign(
  { userId: "id123", email: "xxx@xxx.com" }, // payload
  "secret_key", // 개인키
  { expiresIn: "3h" } // 옵션
);
```

토큰을 콘솔에 찍어보면 다음과 같이 잘 생성된 것을 확인할 수 있다.

```jsx
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
  .eyJ1c2VySWQiOiJpZDEyMyIsImVtYWlsIjoieHh4QHh4eC5jb20iLCJpYXQiOjE3MTIxMTkzNjQsImV4cCI6MTcxMjEzMDE2NH0
  .BkHLc1tYR6v - _pv6aI0qoiFATqVXGnNNy8aUA6FQBN0;
```

### ✔️ verify

토큰을 검증할 땐 `verify` 메소드를 활용한다.

첫번째 인자로 토큰, 두번째 인자로 개인키, 세번째 인자로는 콜백 함수를 전달한다.

```jsx
// 검증
jwt.verify(token, "secret_key", (err, decoded) => {
  console.log(decoded);
});
```

decoded된 데이터를 찍어보면 다음과 같이 payload 값을 확인할 수 있다.

```jsx
{
  userId: 'id123',
  email: 'xxx@xxx.com',
  iat: 1712119292,
  exp: 1712130092
}
```
