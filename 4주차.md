## 📍 req.params

요청 객체인 `req` 에는 매개변수를 담은 ‘params’ 속성이 있다.

parameter를 가져올 땐 endpoint에 콜론(:)을 이용해서 명시해주면 된다!

```jsx
// https://www.youtube.com/@15ya.fullmoon (youtube 채널 주소)

app.get('/:nickname', (req, res) => {
	const { nickname } = req.params;

	res.json({
		channel: nickname;   // "@15ya.fullmoon"
	});
});
```

<br />

## 📍 req.query

쿼리 스트링이 담긴 ‘query’ 속성을 이용하면, `?` 뒤로 이어지는 ‘key=value’ 형태의 쿼리 스트링을 받아올 수 있다.

아래 코드는 youtube 영상의 타임라인 주소에서 쿼리 스트링을 뽑아내는 코드이다.

```jsx
// https://www.youtube.com/watch?v=MwK3woTDnbo&t=785s (타임라인 주소)

app.get('/watch', (req, res) => {
	const { v, t } = req.query;

	res.json({
		video: v;     // "MwK3woTDnbo"
		time: t;      // "785s"
	});
});
```

<br />

## 📍 req.body

클라이언트에서 body에 담아 보낸 JSON 데이터를 담고 있는 속성이다.

```jsx
// 클라이언트 요청
await axios.post('/test', {
    key: 'value',
});

// 서버 응답
app.get('/test', (req, res) => {
	const { key } = req.body;

	res.json({
		key: key;
	});
});
```

<br />

## 📍 자바스크립트 네이밍 룰

### ✔️ 네이밍 컨벤션의 종류

```jsx
// 파스칼 케이스 (PascalCase)
var NameRules;

// 카멜 케이스 (camelCase)
var nameRules;

// 스네이크 케이스 (snake_case)
var name_rules;
```

### ✔️ 기본 원칙

기본적으로 자바스크립트는 변수 또는 함수에 카멜 케이스를, 생성자 함수와 클래스 이름에는 파스칼 케이스를 사용한다.

- 변수명은 이름만 봐도 쓰임새를 알 수 있도록 **자체 설명적**이어야 한다.
  ```jsx
  let q; // X
  let query; // O
  ```
- 이름의 앞뒤에 **언더바(\_)**를 사용하지 않는다.
  ```jsx
  let _id_; // X
  let id_; // X
  let _id; // X
  ```
- 약어는 **모두 대문자** 혹은 **모두 소문자**로 표기한다.
  ```jsx
  let HTTPRequests; // O
  let httpRequests; // O
  ```
- export되는 파일 내의 모든 상수는 **모두 대문자**로 표기한다.
  ```jsx
  export const API_KEY = "KEY";
  ```
- 이름에 **복수형**을 표기하지 않는다.
  ```jsx
  let todos = ["one", "two"]; // O
  let todo_list = ["one", "two"]; // X
  ```

<br />

## 📍 Map

자바스크립트의 Map 객체는 key-value 쌍으로 이루어진 집합이다.

기존 객체와 달리 메소드를 이용해 값을 조작한다.

```jsx
const map = new Map();

// 데이터 삽입
map.set("a", 1);
map.set("b", 2);
map.set("c", 3);

// 데이터 조회
map.get("a");

// 데이터 삭제
map.delete("c");

// 전체 삭제
map.clear();
```

### ✔️ Map의 장점

Map이 기존 객체에 비해 가지는 장점은 무엇일까?

- **키 값의 type에 대한 자유로움**

  기존 객체에서는 문자열(String) 혹은 심볼(Symbol)만 키 값으로 사용할 수 있었던 것과 달리 숫자나 객체를 포함한 모든 자료형을 사용할 수 있다.

  ```jsx
  const numberMap = new Map([
    [1, "one"],
    [2, "two"],
    [3, "three"],
  ]);

  numberMap.get(2); // "two"
  ```

- **메소드 사용의 명확성**

  `.` 이나 `[]` 를 사용해서 값에 접근했던 기존 객체와 달리 메소드로만 값에 접근할 수 있는 점은 객체보다 동작과 의도를 더 정확하게 보여준다고 할 수 있다.

  ```jsx
  let originObj = {
    // ...
  };

  const mapObj = new Map([
    // ...
  ]);

  // 객체 -> 빈 객체 할당해서 초기화
  originObj = {};

  // 맵 -> clear 메소드로 초기화
  mapObj.clear();
  ```

- **더 편리한 순회**
  기존 객체는 `for..in` 문, 혹은 `Object.keys` 를 이용해서 순회를 할 수 있는데, 이 두 방법은 객체의 키 값만을 순회하기 때문에 그 키 값을 이용해서 value를 다시 얻어내야 한다.
  반면 Map 객체는 그 자체로 `for..of` 문을 사용할 수 있어 순회하는 데 더욱 편리하다.

  ```jsx
  const map = new Map([
    ["key1", "value1"],
    ["key2", "value2"],
    ["key3", "value3"],
  ]);

  for (const [key, value] of map) {
    console.log(key, value);
  }

  /*
  	"key1" "value1"
  	"key2" "value2"
  	"key3" "value3"
  */
  ```

<br />

## 📍 Express generator

Express의 기본 환경을 구성하기 위해서는 express-generator를 사용할 수 있다.

### ✔️ 설치

먼저 터미널에서 express-generator를 설치해준 뒤,

```bash
sudo npm i express-generator -g
```

`express` 를 터미널에 입력하면 다음과 같은 화면이 나온다.

<img width="508" alt="스크린샷 2024-03-19 오전 11 46 59" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/b44bc66a-deff-4739-961f-0fc46e714dc7">

그리고 해당 폴더 안에 이와 같이 기본적인 패키지가 세팅되어 있는 것을 확인할 수 있음!

<img width="212" alt="스크린샷 2024-03-19 오전 11 47 32" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/fdceca79-c598-48fa-a84c-7e8a8dc1bb90">

<br />

## 📍 Express의 구조

### ✔️ bin/www

http 모듈에 express 모듈을 연결하고 포트를 지정하는 파일이다.

```jsx
// 모듈 불러오기
var app = require("../app");
var debug = require("debug")("express-base:server");
var http = require("http");

// 포트 설정
port = normalizePort(process.env.PORT || "3000");
app.set("port", port);

// http 서버 생성!
var server = http.createServer(app);

// 서버 구동
server.listen(port);
server.on("error", onError);
server.on("listening", onListening);
```

### ✔️ app.js

미들웨어를 거쳐 클라이언트의 요청을 받아 처리한 후, 다시 클라이언트에게 응답하는 파일이다.

```jsx
// 모듈 불러오기
var createError = require("http-errors");
var express = require("express");
var path = require("path");
var cookieParser = require("cookie-parser");
var logger = require("morgan");

var indexRouter = require("./routes/index");
var usersRouter = require("./routes/users");

// express 서버 생성
var app = express();

// view engine setup
app.set("views", path.join(__dirname, "views"));
app.set("view engine", "jade");

// 미들웨어 연결
app.use(logger("dev"));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, "public")));

app.use("/", indexRouter);
app.use("/users", usersRouter);

// ...

module.exports = app;
```

<br />

## 📍 자바스크립트 함수의 종류

### ✔️ 선언적 함수

가장 기본적인 방법.

호이스팅이 되기 때문에 어디서든 호출할 수 있다.

```jsx
function func() {
  console.log("Hello");
}
```

### ✔️ 익명 함수 (대입형 함수)

한 줄씩 읽으며 생성되기 때문에 선언 후에만 사용할 수 있다.

```jsx
const sayHello = function () {
  console.log("Hello");
};
```

### ✔️ 일급 함수

함수 스스로가 객체로, 즉 값으로 사용되는 것을 말한다.

익명 함수, 콜백 함수가 여기에 해당!

```jsx
function func() {
  return "Hello";
}

function func2(func) {
  console.log(func());
}

func2(func);
```

### ✔️ 화살표 함수

ES6의 화살표 문법을 사용하는 방법이다.

```jsx
const func = () => {
  console.log("Hello");
};
```

### ✔️ 즉시 실행 함수

선언과 동시에 실행되는 함수로, 재사용하지 않는 경우에 해당한다.

→ ex) 콜백 함수!

```jsx
(function () {
  console.log("hello");
})();

(() => {
  console.log("hello");
})();
```

<br />

## 📍 app.use()

express에는 http 모듈 외에도 다른 모듈들을 미들웨어로 사용할 수 있다.

`use()` 를 활용하면 미들웨어를 연결할 수 있음!

```jsx
app.use(express.json());

app.post("/test", (req, res) => {
  console.log(req.body);
});
```

<br />

## 📍 youtuber 실습

→ POST로 새로운 youtuber 등록해보기!

### ✔️ API 설계

- `GET /youtuber/:id` : id로 map에서 youtuber 객체를 찾아서, 해당 객체의 정보를 뿌려줌.
  - **req**: params.id ← map에 저장된 key 값 전달.
  - **res**: id를 이용하여 map에서 객체 조회 후 전달.
- `POST /youtuber` : 새로운 유튜버 등록.
  - **req**: 새로운 유튜버 정보를 body에 담아서 전달. (channel, sub, video)
  - **res**: “channel님, 유튜버 생활을 응원합니다!”

### ✔️ GET API 구현

youtuber의 id 값을 전달받아 db에서 조회한 후 조회된 값을 응답으로 돌려준다.

```jsx
app.get("/youtuber/:id", (req, res) => {
  let { id } = req.params;
  id = parseInt(id);
  const youtuber = db.get(id);

  // 유튜버가 없다면?
  if (youtuber === undefined) {
    res.json({
      message: "존재하지 않는 유튜버입니다.",
    });
  }
  // 유튜버가 있다면?
  else {
    res.json(youtuber);
  }
});
```

### ✔️ POST API 구현

body 값을 구조 분해 할당한 후 db에 등록해주고, 응답 값을 전달한다.

db에 등록할 때 해당 youtuber의 id 값은 db에 존재하는 youtuber 수에 따라 차례대로 할당되게끔 했다.

```jsx
app.post("/youtuber", (req, res) => {
  const { channel, sub, video } = req.body; // 요청 body 값 꺼내기
  const newId = db.size + 1; // id 구하기

  // db에 등록!
  db.set(newId, { channel, sub, video });

  // 응답 전송
  res.json({
    message: `${db.get(newId).channel}님, 유튜버 생활을 응원합니다!`,
  });
});
```

Postman 테스트 결과도 다음과 같이 잘 작동되는 것으로 확인 완!

<img width="686" alt="스크린샷 2024-03-20 오전 11 47 07" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/2a22da68-58f0-4cff-9e0c-0a8efc0fc0d9">

<br />

## 📍 youtuber 전체 조회

db에 있는 모든 youtuber들에 대한 정보를 전체 조회할 수 있는 API를 구현할 것이다.

### ✔️ API 설계

- `GET  /youtubers` : 전체 youtuber 정보를 전체 조회한다.
  - **req**: 전달 값 없음!
  - **res**: 전체 youtuber의 정보 전달

### ✔️ GET API 구현

현재는 ‘db’라고 정의해놓은 map 객체를 DB 대신 사용하고 있기 때문에, map을 기존의 javascript 객체로 바꿔서 전달해줬다.

```jsx
app.get("/youtubers", (req, res) => {
  // map -> object로 변경
  const obj = {};
  db.forEach((value, key) => {
    obj[key] = value;
  });

  // 전체 데이터 전송
  res.json(obj);
});
```

Postman 테스트 결과 잘 나오는 것까지 확인!

→ 새로 추가한 youtuber 데이터도 알맞게 추가된 것을 볼 수 있다.

<img width="682" alt="스크린샷 2024-03-20 오후 12 22 28" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/08ed277b-d071-4c39-a90d-69070f6ce627">
