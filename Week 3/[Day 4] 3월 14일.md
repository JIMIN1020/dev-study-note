## 📍 HTTP method

HTTP 메소드는 클라이언트-서버 구조에서 요청과 응답이 이루어지는 방식을 말한다.

서버가 수행해야할 동작을 지정하여 요청을 보내는 것!

### ✔️ 주요 method

- **GET**: 리소스 조회
- **POST**: 요청 데이터 처리, 주로 등록에 사용
- **PUT**: 덮어쓰기(업데이트), 해당 리소스가 없으면 생성
- **PATCH**: 리소스 부분 변경 (PUT은 전체 변경, PATCH는 일부 변경)
- **DELETE**: 리소스 삭제

### ✔️ 기타 method

- **HEAD**: GET과 비슷하나 body를 제외하고, status와 header만 반환
- **OPTIONS**: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
- **CONNECT**: 서버에 대한 터널을 설정
- **TRACE**: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

<br />

## 📍 Node.js의 특징

Node.js는 JavaScript로 서버를 구축하고 서버에서 JavaScript가 작동되도록 해주는 런타임 환경(플랫폼)이다.

고급 언어로 작성된 소스 코드를 기계어로 변환하는 과정을 런타임이라 하고, 다시말해 Node.js는 JS를 컴퓨터가 이해할 수 있는 기계어로 변환시켜주는 역할을 한다.

따라서 기존에 스크립트 언어로 웹 브라우저 안에서만 동작했던 JS가 Node.js를 통해 어플리케이션을 개발하는 프로그래밍 언어로 동작할 수 있게 되는 것!

### ✔️ 싱글 스레드

멀티 스레드에 반대되는 개념으로, 하나의 스레드만을 사용하는 방법이다.

→ 즉, 한번에 하나의 작업만을 할 수 있다!

자바스크립트는 웹 브라우저에서 동작하도록 만들어진 스크립트 언어이기 때문에 멀티 스레드 환경은 고려되지 않았다.

하나의 프로세스에서 하나의 스레드를 사용하는 것은 CPU 등의 자원을 효율적으로 사용하지 못하는 방법이지만, 멀티 스레드 환경에서 발생할 수 있는 공유 자원 동시접근 문제나 context switch 등을 고려하지 않아도 되는 장점이 있다.

### ✔️ 이벤트 기반

Node.js는 싱글 스레드이기 때문에 한번에 하나의 작업만을 수행할 수 있다.

그러나 실제로는 여러 비동기 작업을 동시에 수행할 수 있는데, 그 기반에는 이벤트 루프(Event Loop)가 존재한다.

![1*v6jmTRDU2qG4j5UtniYf-Q.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c77d5602-64fa-451c-8850-1a5cea7e87d3/04a929b2-0f0c-4636-9274-3c36420d093e/1v6jmTRDU2qG4j5UtniYf-Q.png)

Node.js는 Chrome V8 자바스크립트 엔진과 비동기 작업을 처리하는 Libuv 라이브러리로 이루어져있다.

여기서 자바스크립트 엔진은 비동기 작업을 처리할 수 없기 때문에 비동기 작업이 요청된 경우 libuv 라이브러리를 통해 비동기 작업을 처리한다.

libuv는 이벤트 기반으로 비동기를 처리하는데, 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 말한다.

마치 버튼을 클릭했을 때 alert가 뜨게 이벤트를 등록하는 것처럼, 이벤트 발생 시 이벤트 리스너에 등록해 둔 콜백함수를 호출한다.

만약 여러 이벤트가 동시에 발생했을 때, 어떤 순서로 콜백 함수를 호출할지는 이벤트 루프가 결정한다.

→ 이벤트 루프는 이벤트 발생 시 호출한 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할

### ✔️ 논블로킹 I/O

블로킹 I/O는 프로그램 내부에서 함수를 호출하면 호출된 함수가 작업을 마칠 때까지 대기하는 방식이고,

논 블로킹 I/O는 함수가 실행되는 중에도 다른 작업을 동시에 진행할 수 있는 방식을 말한다.

→ I/O 작업 중 다른 요청을 blocking 하지 않는다는 것!

다음 코드는 first → second → third 순으로 함수를 실행하는 코드이다.

이때 second는 `setTimeout` 함수를 통해 2초 뒤 실행되도록 처리했을 때,

```jsx
function first() {
  console.log("first");
}

function second() {
  console.log("second");
}

function third() {
  console.log("third");
}

first();
setTimeout(second, 2000); // 2초 뒤 실행
third();
```

결과는 다음과 같이 `setTimeout` 이 실행되는 동안 `third()` 함수가 실행되어 먼저 종료되었고, 그 후 `second()` 가 실행된 것을 볼 수 있다.

<img width="411" alt="스크린샷 2024-03-14 오전 11 00 31" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/7b2e127d-2c14-474e-a258-6d331a9a8487">

<br />

## 📍 프레임워크 vs 라이브러리

### ✔️ 프레임워크

프레임워크는 개발자가 개발을 쉽게 할 수 있도록 뼈대를 제공한다.

어떠한 소프트웨어를 만들기 위한 필수적인 코드, 라이브러리, 알고리즘, DB 커넥션 등과 같은 기능의 집합으로, 개발자는 이러한 틀 내에서 쉽고 빠르게 개발을 할 수 있다.

예를 들면 Java 기반의 서버 개발을 위한 Spring, 파이썬 기반의 서버 개발을 위한 Django, 안드로이드 개발에 사용되는 Android 프레임워크 등이 있다.

### ✔️ 라이브러리

라이브러리는 개발자가 필요에 따라 자신의 코드에 가져다가 사용할 수 있는 재사용 가능한 함수, 클래스, 메서드 등의 집합이다.

자주 쓰는 메소드 및 특정 기능을 하는 함수들을 미리 구현해 놓고, 프로그램에 추가해서 사용하는 형태!

예를 들어 C++ 의 STL, npm으로 설치한 모듈 등이 라이브러리에 해당한다.

### ✔️ 제어의 역전 (Inversion of Control)

프레임워크와 라이브러리의 가장 큰 차이점은 제어흐름이 어디에 있는지이다.

프레임워크는 제어의 역전이라는 개념이 적용되는데, 프레임워크에게 제어의 흐름을 넘겨 개발자가 신경 써야 할 부분을 줄인다는 뜻이다.

개발자는 프레임워크가 정해준 방식대로 코드를 작성하며, 개발자가 작성한 애플리케이션 코드는 프레임워크가 짜놓은 틀 안에서 수동적으로 동작한다.

반면 라이브러리는 개발자가 필요할 때마다, 필요한 곳에 직접 호출하여 사용하기 때문에 전적인 제어 흐름이 개발자에게 있다.
