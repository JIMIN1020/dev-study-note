## 📍 fast-forward 전략

A 브랜치에서 B 브랜치를 생성한 시점부터 A 브랜치에는 아무런 추가 구현을 하지 않고,

B 브랜치에만 추가 구현을 한 뒤 B 브랜치를 A 브랜치에 합치는 것!

![img](https://github.com/JIMIN1020/dev-study-note/assets/121474189/bc7b8069-046d-424e-b1c2-3eae8356a62c)

<br />

## 📍 3-way 전략

일반적으로 가장 많이 사용하는 전략.

A 브랜치에서 B 브랜치를 생성한 시점부터,

A 브랜치도 추가 구현을 하고, B 브랜치도 추가 구현을 하고,

A 브랜치와 B 브랜치를 합칠 때 서로 비교하여 바뀐 것을 정리하여 합치는 것!

![image-6](https://github.com/JIMIN1020/dev-study-note/assets/121474189/2d9f9646-4fcb-41d4-a7b8-f02558ef452e)

<br />

## 📍 branch protection rules

Github에서는 브랜치를 보호하기 위한 rule을 지정할 수 있다.

브랜치에 대해 rule을 적용함으로써 브랜치가 실수로 지워지거나, pr 외의 방법으로 코드를 수정하는 것을 막는 등 프로젝트에 대한 안정성을 강화할 수 있다!

Github repo의 `settings` 에 들어가면 branch 카테고리가 있고, 여기서 rule을 지정할 수 있다.

rule을 만들기 전에는 아래와 같이 뜨는 상태!

<img width="1416" alt="스크린샷 2024-03-04 오전 10 17 05" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/a152b865-3256-4ecd-8512-57ccfc28d38c">

`Add branch protection rule` 을 클릭하면 다음 페이지에서 rule을 설정할 수 있다.

<img width="1136" alt="스크린샷 2024-03-04 오전 10 18 51" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/48741d44-3f50-4dff-afd4-ed1fa8e03ed8">

‘Branch name pattern’은 특정 브랜치에만 rule을 적용하고 싶으면 그 브랜치 명을 적어주면 되고,

만약 특정 경로에 위치하는 모든 브랜치, 예를 들어 ‘feat/#12’ 와 같은 기능 브랜치들에 모두 적용하고 싶다면 `feat/*` 이와 같이 적어주면 된다!

설정할 수 있는 rule을 보면 코드 리뷰를 강제하거나 브랜치를 read-only로 만드는 등의 다양한 rule이 존재한다!

<br />

## 📍 Web이란?

월드 와이드 웹(World Wide Web)이란, 인터넷에 연결된 컴퓨터를 통해 정보를 공유할 수 있는 공간을 말한다.

줄여서 WWW, W3, Web이라고 부른다.

- **Web의 시작**

  1980년대, 스위스의 한 유럽 입자 물리 연구소(CERN)의 컴퓨터과학자 팀 버너스-리에 의해 탄생됨

  연구원들 간 신속한 정보교환을 위해 고안되었던 것!

- **Web의 특징**
  정보를 하이퍼텍스트(HyperText) 형식으로 표현하여, 하이퍼텍스트를 따라 이동하며 다양한 정보/문서들을 연결, 제공한다.
  → 하이퍼텍스트는 단순히 글자가 아닌 그 이상의 기능을 가진 텍스트로, 주로 링크, 참조의 역할을 하는 기술!

<br />

## 📍 Web의 구조

웹은 클라이언트 - 서버 구조로 구성되어 있다.

인터넷으로 연결된 클라이언트와 서버는 웹 프로토콜인 HTTP를 사용하여 데이터를 주고받는다.

- **클라이언트(Client):** 서비스를 요청하는 컴퓨터
- **서버(Server):** 서비스를 제공하는 컴퓨터
- **프로토콜 (protocol):** 웹 상에서 서로 통신하며 정보를 주고 받을 때 지켜야하는 규칙.

<br />

## 📍 Web 개발 직무

- **프론트엔드**

  웹 사이트에서 사용자 측면(client-side)의 그래픽 사용자 인터페이스로,

  사용자와의 상호작용(입력, 클릭, 출력 등)을 담당한다.

- **백엔드**
  웹 사이트에서 사용자의 눈에 보이지 않는 서버 측(server-side)에서,
  프론트엔드에서 전달받은 데이터와 요청을 내부 데이터와 연산을 활용하여 처리하고 결과를 전달한다.

<br />

## 📍 CSS

Cascading Style Sheets의 약자로, HTML 태그를 꾸며주는 언어이다.

문서를 통째로 꾸며주는 것이 아니라, 태그 하나하나를 꾸며주는 것!

- **인라인(inline):** HTML 태그 안에 작성

  ```html
  <div style="width: 120px"></div>
  ```

- **내부 스타일 시트(internal style sheet):** HTML 문서 내 <head> 태그 안에 작성

  ```html
  <html>
    <head>
      <style>
        .box {
          width: 120px;
        }
        #line {
          width: 100px;
        }
      </style>
    </head>
    <body>
      <div class="box">box</div>
      <div id="line">line</div>
    </body>
  </html>
  ```

- **외부 스타일 시트(external style sheet):** HTML 문서 밖에 .css 파일을 만들어 작성하고 연결

  ```html
  <html>
    <head>
      <link rel="stylesheet" href="myStyle.css" />
    </head>
    <body>
      <div class="box">box</div>
      <div id="line">line</div>
    </body>
  </html>
  ```

  ```css
  .box {
    width: 120px;
  }

  #line {
    width: 100px;
  }
  ```

<br />

## 📍 JavaScript

JS는 특정 HTML 요소를 선택하여 제어할 수 있는 스크립트 언어이다.

→ 글자를 바꾸거나, 색을 바꾸거나, 사용자와 상호작용하는 작업

- **스크립트 언어란?**

  독립적인 프로그램을 개발할 수 있는 언어가 아닌 프로그램 내부 구성 요소 중 하나로 프로그램을 제어하는 역할을 하는 언어.

  최근 빠르게 발전하는 런타임 환경 때문에 스크립트 언어 만으로도 충분히 프로그래밍이 가능해져서 역할이 확장되고 있다.

  → 최근 백엔드 언어로도 각광받고 있음!

- **인라인 (inline):** 사용자와의 상호작용이 있을 때만 가능

  → ex) 버튼 클릭, 키보드 클릭

  ```jsx
  <html>
    <body>
      <button onClick="alert('clicked!')">button</button>
    </body>
  </html>
  ```

- **내부 스크립트 (internal script):** HTML 문서 안에 작성

  ```html
  <html>
    <body>
      <div id="box">
        <button onclick="{onClickBtn}">button</button>
      </div>
    </body>

    <script>
      // 함수 만들기
      function onClickBtn() {
        alert("clicked!");
      }
      // 특정 태그 가져오기
      let box = document.getElementById("box");
    </script>
  </html>
  ```

- **외부 스크립트 (external script):** HTML 문서 밖에 .js 파일을 만들어 작성하고 연결
  ```jsx
  <html>
    <head>
      <script type="text/javascript" src="myScript.js" />
    </head>
    <body>
      <button onclick={onClickBtn}>button</button>
    </body>
  </html>
  ```
  ```jsx
  function onClickBtn() {
    alert("clicked!");
  }
  ```

<br />

## 📍 백엔드의 구조

- **웹 서버 (Web Server)**

  정적 페이지에 대해 대응하는 역할로, 동적 페이지에 대한 처리는 웹 어플리케이션 서버에게 전달한다.

  - **정적 페이지:** 화면의 내용/데이터 등의 변동이 없는 페이지
  - **동적 페이지:** 데이터 처리/연산을 통해 화면의 내용, 데이터가 변하는 페이지

- **웹 어플리케이션 서버 (Web Application Server)**
  동적 페이지를 처리하는 역할로, 필요한 데이터 연산을 위해 데이터베이스와 연결되어 있으며 데이터 조회, 수정, 삭제에 대한 처리를 요청한다.

<br />

## 📍 Node.js의 이해

Node.js는 자바스크립트를 스크립트 언어 이상의 프로그래밍 언어 역할을 할 수 있도록 지원하는 런타임 환경이다.

→ Node.js를 이용하여 자바스크립트로 백엔드를 구현할 수 있음!

### ✔️ Node.j로 웹 서버 만들기

```jsx
let http = require("http");

function onRequest(req, res) {
  res.writeHead(200, { "Content-Type": "text/html" });
  res.write("Hello Node.js");
  res.end();
}

http.createServer(onRequest).listen(8888);
```

### ✔️ server 모듈화

Node.js가 제공하는 모듈 이외에 직접 만든 서버 코드도 다른 코드에서 모듈처럼 불러서 사용할 수 있다.

`index.js` 를 만들고 server 파일을 다음과 같이 불러와서 사용하면 끝!

```jsx
let server = require("./server");
```

그러나 지금은 모듈을 불러오기만 해도 서버가 시작되는 상태이기 때문에 여전히 유연성은 떨어진다.

다음과 같이 서버 모듈을 불러온 뒤 원할 때 서버를 시작하게 코드를 변경하면 된다.

```jsx
let http = require("http");

// 서버 시작 함수
function start() {
  function onRequest(req, res) {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.write("Hello Node.js");
    res.end();
  }

  http.createServer(onRequest).listen(8888);
}

// 서버 시작 함수 내보내기
exports.start = start;
```

```jsx
let server = require("./server");

server.start(); // 서버 시작!
```

<br />

## 📍 URL

→ Uniform Resource Locator

인터넷 상에서 웹 페이지의 위치를 알려주는 주소이다.

### ✔️ url 읽어오기

최대한 의존성을 낮추도록 각 파일을 분리하여 url을 콘솔에 출력하도록 코드를 작성한다.

```jsx
function route(pathname) {
  console.log("pathname: ", pathname);
}

exports.route = route;
```

```jsx
let server = require("./server");
let router = require("./router");

server.start(router.route); // route 함수 전달!
```

```jsx
let http = require("http");
let url = require("url");

// 서버 시작 함수
function start(route) {
  function onRequest(req, res) {
    // url 읽어오기
    let pathname = url.parse(req.url).pathname;
    route(pathname);

    // 서버 응답 생성
    res.writeHead(200, { "Content-Type": "text/html" });
    res.write("Hello Node.js");
    res.end();
  }

  http.createServer(onRequest).listen(8888);
}

// 서버 시작 함수 내보내기
exports.start = start;
```

<br />

## 📍 서버 코드 분석해보기

url에 따라 다른 response를 보내도록 routing 처리를 한 서버 코드이다.

### ✔️ server.js

여기서 `start` 함수는 서버를 시작하는 역할을 하는데,

요청이 오면 해당 요청의 URL을 parsing하고, 해당 URL을 기반으로 라우팅 함수를 호출한다.

```jsx
const http = require("http");
const url = require("url");

function start(route, handle) {
  http
    .createServer((req, res) => {
      const pathname = url.parse(req.url).pathname;
      route(pathname, handle, res);
    })
    .listen(8888, () => console.log("server listening on port:8888..."));
}

exports.start = start;
```

- **http 모듈:** http 웹 서버와 관련된 모든 기능을 담은 모듈. (웹서버 생성, 클라이언트 생성 등)
- **url 모듈:** url 정보를 객체로 가져와서 분석하고 처리하는 역할을 하는 모듈.
- **listen**: 서버를 실행하는 메소드. 서버가 실행될 포트번호와 콜백 함수를 전달할 수 있다.

- **url.parse()**

  요청 url을 전달하면 다음과 같이 url 객체로 변환하여 반환한다.

    <img width="437" alt="스크린샷 2024-03-07 오후 7 21 24" src="https://github.com/JIMIN1020/dev-study-note/assets/121474189/ce85f9a0-eb87-424d-bf73-897ba7c21333">
    
    ‘url.parse(req.url)’를 출력한 결과
    
    - **parse의 뜻?**
        
        사전적 정의는 ‘문법적으로 분석하다’라는 뜻으로, 개발 용어로 사용될 땐 **분해, 분석하여 목적에 맞게 가공하고 추출하는 것**을 말한다. 그리고 이러한 parsing을 수행하는 프로그램을 parser라 부른다.
        
        대표적으로 자바스크립트에서는 string 형태로 작성된 객체를 JSON 형태로 parsing하여 사용하곤 한다.
        
        ```jsx
        const rawData = "{ name : 홍길동, age : 21 }";   // string 형태의 객체
        const jsonData = JSON.parse(rawdata);          // JSON 형태로 parsing!
        ```

- **exports vs module.export**

  ```jsx
  const module = { exports: {} };
  const exports = module.exports;
  ```

  exports와 module.exports는 동일한 객체라고 볼 수 있으나, **exports는 module.exports를 참조(call by reference)**하고 있는 형태이다.
  따라서 exports에 데이터를 바로 대입하면 module.exports에 대한 참조가 끊어지고 해당 데이터의 값을 가지게 된다.

  ```jsx
  const obj = {
    key1: "v1",
    key2: "v2",
  };

  module.exports = obj; // 가능
  module.exports.obj = obj; // 가능

  exports = obj; // 불가능 -> module.exports에 대한 참조가 끊김
  exports.obj = obj; // 가능
  ```

  → `exports` 는 `module.exports` 로 대체할 수 있음!

### ✔️ router.js

요청 경로와 요청 핸들러를 받아와서, 해당 경로에 따라 적절한 응답을 처리한다.

만약 해당 경로가 정의되어 있지 않으면 404 페이지를 호출함!

```jsx
function route(pathname, handle, res) {
  if (typeof handle[pathname] === "function") {
    handle[pathname](res);
  } else {
    handle["/404"](res);
  }
}

exports.route = route;
```

### ✔️ requestHandler.js

각 경로에 맞는 응답 값을 처리하는 함수들이 정의되어 있다.

```jsx
function main(res) {
  res.writeHead(200, { "Content-Type": "text/html" });
  res.write("Main Page");
  res.end();
}

function login(res) {
  res.writeHead(200, { "Content-Type": "text/html" });
  res.write("Login Page");
  res.end();
}

function notFound(res) {
  res.writeHead(404, { "Content-Type": "text/html" });
  res.write("404 Not Found");
  res.end();
}

let handle = {
  "/": main,
  "/login": login,
  "/404": notFound,
};

exports.handle = handle;
```

- **writeHead():** 응답 헤더에 들어갈 정보를 전달하는 메소드. HTTP 상태코드와 응답 형식을 전달한다.
- **write():** 본문(body)에 보여질 내용을 전달하는 메소드.
- **end():** 응답을 종료하는 메소드.

### ✔️ index.js

각 모듈들을 가져와서 서버를 시작하는 코드.

```jsx
let server = require("./server");
let router = require("./router");
let requestHandler = require("./requestHandler");

server.start(router.route, requestHandler.handle);
```

이 코드를 통해 요청이 들어오면 서버가 이를 받아서 적절한 페이지로 라우팅하고,

해당 페이지에 대한 응답을 생성하여 클라이언트에게 보내주는 기본적인 웹 서버가 만들어지는 구조!

<br />

## 📍 데이터베이스 (DB; Data Base)

데이터를 통합하여 효율적으로 관리하기 위한 데이터 집합체.

데이터를 구조화하여 관리함으로써 데이터 중복을 막고, 효율적이고 빠른 데이터 연산을 가능하게 한다.

기존의 파일 시스템이 가지는 종속성, 중복성 문제를 해결하기 위해 고안된 것!

- **DBMS (DataBase Management System)**
  데이터베이스를 운영하고 관리하기 위한 시스템.
  응용 프로그램들이 데이터베이스에 접근할 수 있는 인터페이스를 제공하고 장애 복구 기능, 사용자 권한에 따른 보안성 유지 기능 등을 제공한다.
  DBMS에는 여러 종류가 있으나, 연산을 하는 주요 명령어는 동일하다.
  - **대표적인 DBMS 종류**
    - Oracle
    - MySQL
    - Maria

<br />

## 📍 SQL (Structured Query Language)

데이터베이스에 연산을 요청하기 위해 사용되는 언어로, 데이터 생성, 조회, 수정, 삭제 등과 같은 기능을 수행할 수 있다.

- **대표적인 SQL**
  - 데이터 삽입: `**INSERT**`
  - 데이터 조회: `**SELECT**`
  - 데이터 수정: `**UPDATE**`
  - 데이터 삭제: `**DELETE**`

### ✔️ DB 만들기

```sql
SHOW DATABASE;         // DB 확인
CREATE DATABASE DB명;   // DB 생성
USE DB명;               // DB 접속
```

### ✔️ Table 만들기

```sql
// table 확인하기
SHOW TABLES;

// table 생성
CREATE TABLE table명
(
	column1 INT,
	column2 VARCHAR(30),
	column3 VARCHAR(30)
);
```

### ✔️ 데이터 조회/삽입하기

```sql
// 데이터 조회
SELECT * FROM table명;                  // 전체 조회
SELECT column명 FROM table명;            // 특정 column 선택 조회
SELECT column명 FROM table명 WHERE 조건;  // 조건부 조회

// 데이터 삽입
INSERT INTO table명 VALUES (col1 데이터, col2 데이터, ...);  // 전체 column 값 추가
INSERT column1, column2 INTO table명 VALUES (col1 데이터, col2 데이터);
```

### ✔️ 데이터 수정/삭제하기

```sql
// 데이터 수정
UPDATE table명 SET column명 = 수정값 WHERE 조건;

// 데이터 삭제
DELETE FROM table명 WHERE 조건;
DELETE FROM table명;  // 전체 삭제
```

<br />

## 📍 Docker

![docker-containerized-appliction-blue-border_2](https://github.com/JIMIN1020/dev-study-note/assets/121474189/986eedca-e918-4a87-980d-94cf857b9474)

docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 오픈소스 가상화 플랫폼이다.

가상의 환경에서 소프트웨어를 실행시키기 위해 리눅스의 컨테이너(container)라는 단위로 패키징한다.

docker를 사용하면 환경에 구애받지 않고 애플리케이션을 개발하고 배포할 수 있다!

### ✔️ 컨테이너 (container)

컨테이너는 격리된 공간에서 프로세스가 동작하는 가상화 기술이다.

컨테이너 안에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든 것이 포함되어있어, 소프트웨어가 동일한 환경에서 실행될 수 있도록 한다.

이러한 컨테이너는 호스트 시스템과 분리되어 독립적으로 실행되며, docker가 설치되어 있는 곳이라면 개발 환경이 달라지더라도 소프트웨어를 동일하게 실행할 수 있다.

그렇다면 docker와 기존 가상화 기술인 가상머신(VM)의 차이점은 뭘까?

![docker-containerized-and-vm-transparent-bg](https://github.com/JIMIN1020/dev-study-note/assets/121474189/fa6ee46b-4c07-49bd-93ae-8f2ac047d5ed)

docker는 여러 컨테이너들이 하나의 머신 위에서 호스트 OS 커널을 공유하고, 소프트웨어를 실행시킬 때 호스트 OS 위에 이미지를 배포하기만 하면 되는 구조로 비교적 가볍다.

VM은 하나의 머신을 여러 개의 guest OS로 나누어 점유하는데, 이는 마치 각각의 다른 머신처럼 동작하는 것이기 때문에 훨씬 복잡하고 무거운 형태이다.

### ✔️ 이미지 (image)

컨테이너 실행에 필요한 모든 파일과 환경을 포함하고 있는 것으로, 더 이상 Dependency 파일을 컴파일하거나 이것저것 설치할 필요가 없는 상태의 파일

이러한 docker 이미지는 일종의 템플릿과 같으며, 이미지를 실행하면 docker 컨테이너가 된다.

이미지는 layer 구조를 가지는데, 여러 개의 필요한 이미지를 쌓아 다양한 환경을 구축할 수 있다.

컨테이너를 생성하게 되면 이미지에 read/write가 가능한 ‘container layer’를 추가한다. 이후 컨테이너가 실행 중에 변경된 사항들은 container layer에 저장되며 컨테이너가 삭제될 때 함께 삭제되므로 이미지에는 영향을 미치지 않는다.

<br />

## 📍 Docker로 MariaDB 실행하기

1. Docker Desktop 실행
2. terminal 실행
3. MariaDB가 있는 컨테이너 접속

   ```jsx
   docker exec -it mariadb /bin/bash
   ```

4. mariadb 실행

   ```jsx
   mariadb -u root -p
   ```

<br />

## 📍 Node.js와 DB 연동

- **mysql 설치**

  ```bash
  npm install mysql --save
  ```

- **mariadb.js 생성**

  ```jsx
  const mariadb = require("mysql");

  // db 연결하기
  const conn = mariadb.createConnection({
    // db 접속 정보
    host: "localhost",
    port: 3306,
    user: "root",
    password: "root",

    // db 정보
    database: "Tennis",
  });

  module.exports = conn;
  ```

- **db 연결하기**

  ```jsx
  const server = require("./server");
  const router = require("./router");
  const requestHandler = require("./requestHandler");

  // db 연결
  const mariadb = require("./database/connect/mariadb");
  mariadb.connect();

  server.start(router.route, requestHandler.handle);
  ```

- **콘솔에 db 내용 찍어보기**

  ```jsx
  const mariadb = require("./database/connect/mariadb");

  mariadb.query("SELECT * FROM product", (err, rows) => {
    console.log(rows);
  });
  ```
